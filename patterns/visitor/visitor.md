# Посетитель
Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.

# Применимость
-  Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.

Посетитель позволяет применять одну и ту же операцию к объектам различных классов.

- Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.

Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции.

- Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.

Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.

# Плюсы
- Упрощает добавление операций, работающих со сложными структурами объектов.
- Объединяет родственные операции в одном классе.
- Посетитель может накапливать состояние при обходе структуры элементов.

# Минусы
- Паттерн не оправдан, если иерархия элементов часто меняется.
- Может привести к нарушению инкапсуляции элементов.

# Реальный пример
Реальный пример использования паттерна "Посетитель" можно найти в компиляторе программного обеспечения.

Компиляторы обычно работают с абстрактным синтаксическим деревом (AST), которое представляет структуру исходного кода программы. Каждый узел этого дерева соответствует определённой конструкции языка программирования (например, операторы, выражения, переменные).

В компиляторе создаётся AST, представляющее исходный код программы. С возможностью выполнения операций:
- Генерация машинного кода
- Оптимизация кода
- Проверка типов
- Интерпретация

Каждая из этих операций реализуется как отдельный "посетитель". Вместо того чтобы добавлять методы для каждой операции в узлы AST, каждый узел принимает "посетителя", который реализует конкретную операцию.
Например, для генерации машинного кода, проверка типов и оптимизация кода создаются разные посетители. Каждый посетитель обходит дерево и выполняет свою задачу, взаимодействуя с каждым узлом.

Этот паттерн применяется по нескольким причинам. Каждая операция, выполняемая над AST, разделена на отдельные классы посетителей, что делает код более модульным и проще в сопровождении. Добавление новой операции не требует изменения существующих узлов AST. Достаточно создать новый класс посетителя, что минимизирует риск ошибок и упрощает тестирование.
Узлы AST не "захламляются" множеством методов для различных операций. Каждый узел содержит только метод для принятия посетителя, сохраняя логику узлов простой и понятной.